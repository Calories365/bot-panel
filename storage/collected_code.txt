

/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/BaseService.php --- */
<?php

namespace App\Services\TelegramServices;

use App\Interfaces\BotHandlerStrategy;
use App\Services\TelegramServices\BaseHandlers\MessageHandlers\AudioMessageHandler;
use App\Services\TelegramServices\BaseHandlers\MessageHandlers\TextMessageHandler;
use App\Services\TelegramServices\BaseHandlers\TextMessageHandlers\StartMessageHandler;
use App\Services\TelegramServices\BaseHandlers\UpdateHandlers\CallbackQueryHandler;
use App\Services\TelegramServices\BaseHandlers\UpdateHandlers\MessageUpdateHandler;
use App\Services\TelegramServices\BaseHandlers\UpdateHandlers\MyChatMemberUpdateHandler;
use Illuminate\Support\Facades\Log;

/**
 * Class BaseService
 *
 * This service implements BotHandlerStrategy to handle Telegram bot updates
 * and distribute them to the appropriate handlers.
 */
class BaseService implements BotHandlerStrategy
{
    protected array $updateHandlers;

    /**
     * BaseService constructor.
     * Initializes the update handlers by calling the getUpdateHandlers method.
     */
    public function __construct()
    {
        $this->updateHandlers = $this->getUpdateHandlers();
    }

    /**
     * BaseService getUpdateHandlers.
     * Collects and returns base UpdateHandlers and for each UpdateHandler passes base subhandlers
     */
    protected function getUpdateHandlers(): array
    {
        $messageUpdateHandler = new MessageUpdateHandler($this->getMessageHandlers());
        $myChatMemberUpdateHandler = new MyChatMemberUpdateHandler();
        $callbackQueryHandler = new CallbackQueryHandler();

        return [
            'message' => $messageUpdateHandler,
            'my_chat_member' => $myChatMemberUpdateHandler,
            'callback_query' => $callbackQueryHandler
        ];
    }

    /**
     * BaseService getMessageHandlers.
     * collects and returns all basic MessageHandlers
     */
    protected function getMessageHandlers(): array
    {
        $textMessageHandler = new TextMessageHandler(
            $this->getTextMessageHandlers()
        );
        $audioMessageHandler = new AudioMessageHandler();

        return [
            'text' => $textMessageHandler,
            'voice' => $audioMessageHandler,
        ];
    }

    /**
     * BaseService getTextMessageHandlers.
     * collects and returns all basic TextMessageHandlers
     */
    protected function getTextMessageHandlers(): array
    {
        $startTextMessageHandler = new StartMessageHandler();

        return [
            '/start' => $startTextMessageHandler,
            '/default' => $startTextMessageHandler
        ];
    }

    /**
     * BaseService handle.
     * starts the required Handler for the event
     */
    public function handle($bot, $telegram, $update): void
    {
        $updateType = $update->detectType();
        if (isset($this->updateHandlers[$updateType])) {
            $this->updateHandlers[$updateType]->handle($bot, $telegram, $update);
        } else {
            Log::info("Unhandled update type: " . $updateType);
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesService.php --- */
<?php

namespace App\Services\TelegramServices;

use App\Services\ChatGPTServices\SpeechToTextService;
use App\Services\DiaryApiService;
use App\Services\TelegramServices\CaloriesHandlers\AudioMessageHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\CallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\CancelCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\DeleteCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\DeleteMealCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery\EditingCancelCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery\EditingSaveCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery\EditingSkipCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\SaveCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\SearchCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\TextMessageHandlers\EditMessageHandler;
use App\Services\TelegramServices\CaloriesHandlers\TextMessageHandlers\LanguageMessageHandler;
use App\Services\TelegramServices\CaloriesHandlers\TextMessageHandlers\StartMessageHandler;
use App\Services\TelegramServices\CaloriesHandlers\TextMessageHandlers\StatsMessageHandler;

class CaloriesService extends BaseService
{
    protected bool $auth = true;
    protected function getUpdateHandlers(): array
    {
        $updateHandlers = parent::getUpdateHandlers();

        $updateHandlers['callback_query'] = new CallbackQueryHandler(
            new CancelCallbackQueryHandler(),
            new SaveCallbackQueryHandler(),
            new EditCallbackQueryHandler(),
            new DeleteCallbackQueryHandler(),
            new EditingSaveCallbackQueryHandler(),
            new EditingCancelCallbackQueryHandler(),
            new EditingSkipCallbackQueryHandler(),
            new SearchCallbackQueryHandler(
                new DiaryApiService(),
                new SpeechToTextService()
            ),
            new DeleteMealCallbackQueryHandler(
                new DiaryApiService(),
            ),
        );

        return $updateHandlers;
    }


    protected function getMessageHandlers(): array
    {
        $messageHandlers = parent::getMessageHandlers();

        $messageHandlers['voice'] = app(AudioMessageHandler::class);

        return $messageHandlers;
    }

    protected function getTextMessageHandlers(): array
    {
        $textMessageHandlers = parent::getTextMessageHandlers();

        $textMessageHandlers['default'] = app(EditMessageHandler::class);
        $textMessageHandlers['/stats'] = new StatsMessageHandler(
            new DiaryApiService()
        );
        $textMessageHandlers['/start'] = new StartMessageHandler(
            new DiaryApiService(),
        );
        $textMessageHandlers['/language'] = new LanguageMessageHandler();
        $textMessageHandlers['Русский'] = new LanguageMessageHandler();
        $textMessageHandlers['English'] = new LanguageMessageHandler();
        $textMessageHandlers['Українська'] = new LanguageMessageHandler();



        return $textMessageHandlers;
    }

}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/TelegramHandler.php --- */
<?php

namespace App\Services\TelegramServices;

use App\Models\Bot;
use Illuminate\Support\Facades\Log;
use Telegram\Bot\Api;
use Telegram\Bot\Objects\Update;

/**
 * Class TelegramHandler
 *
 * this handler realizing the strategy design pattern
 * determines the bot type and launches the corresponding strategy
 */
class TelegramHandler
{
    protected array $strategies;

    public function __construct(
        ApprovalService $approvalService,
        DefaultService  $defaultService,
        RequestService  $requestService,
        Request2Service $request2Service,
        CaloriesService $caloriesService,
    )
    {
        $this->strategies = [
            'Approval' => $approvalService,
            'Default' => $defaultService,
            'Request' => $requestService,
            'Request2' => $request2Service,
            'Calories' => $caloriesService,
        ];
    }

    public function handle($botName, $request): void
    {
        $bot = Bot::with('type')->where('name', $botName)->firstOrFail();

        $botTypeName = $bot->type->name ?? 'unknown';

//        Log::info('Telegram request data: ' . print_r($request->all(), true));

        $telegram = new Api($bot->token);

        $update = new Update($request->all());

        if (!$bot->active) {
            return;
        }

        if (array_key_exists($botTypeName, $this->strategies)) {
            $this->strategies[$botTypeName]->handle($bot, $telegram, $update);
        } else {
            Log::error('Unknown bot type: ' . $botTypeName);
        }
    }
}



/* --- FILE: /var/www/bot-panel/app/Services/DiaryApiService.php --- */
<?php

namespace App\Services;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\GuzzleException;
use Illuminate\Support\Facades\Log;

class DiaryApiService
{
    private Client $client;
    private string $apiUrl;
    private mixed $host;
    private string $diaryApiKey;

    public function __construct()
    {
        $this->diaryApiKey = config('services.diary_api.key');
        $this->apiUrl      = config('services.diary_api.url');
        $this->client      = new Client();
        $this->host        = config('services.diary_api.host');
    }

    /**
     * Унифицированный метод для формирования заголовков запроса.
     *
     * @param int|null    $telegramId
     * @param string|null $locale
     * @return array
     */
    private function getHeaders($telegramId = null, $locale = null): array
    {
        $headers = [
            'Content-Type' => 'application/json',
            'Accept'       => 'application/json',
            'Host'         => $this->host,
            'X-Api-Key'    => $this->diaryApiKey,
        ];

        if (!empty($telegramId)) {
            $headers['X-Telegram-Id'] = $telegramId;
        }

        if (!empty($locale)) {
            $headers['X-Locale'] = $locale;
        }

        return $headers;
    }

    /**
     * Отправляем текст на сервис (пример).
     */
    public function sendText(string $text, $telegram_id, $locale)
    {
        try {
            $response = $this->client->post($this->apiUrl . '/caloriesEndPoint', [
                'headers' => $this->getHeaders($telegram_id, $locale),
                'json'    => [
                    'text' => $text,
                ],
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (GuzzleException $e) {
            Log::error("Error sending text to diary service: " . $e->getMessage());
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Получаем наиболее релевантный продукт
     */
    public function getTheMostRelevantProduct(string $text, $telegram_id, $locale)
    {
        try {
            $response = $this->client->post($this->apiUrl . '/caloriesEndPoint/getTheMostRelevantProduct', [
                'headers' => $this->getHeaders($telegram_id, $locale),
                'json'    => [
                    'text' => $text,
                ],
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (GuzzleException $e) {
            Log::error("Error getting relevant product from diary service: " . $e->getMessage());
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Сохранение продукта
     */
    public function saveProduct(array $data, $telegram_id, $locale)
    {
        try {
            $payload = array_merge($data);

            $response = $this->client->post($this->apiUrl . '/caloriesEndPoint/saveProduct', [
                'headers' => $this->getHeaders($telegram_id, $locale),
                'json'    => $payload,
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (GuzzleException $e) {
            Log::error("Error saving product to diary service: " . $e->getMessage());
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Сохранение употреблённого продукта (приём пищи)
     */
    public function saveFoodConsumption(array $data, $telegram_id, $locale)
    {
        try {
            $payload = array_merge($data);

            $response = $this->client->post($this->apiUrl . '/caloriesEndPoint/saveFoodConsumption', [
                'headers' => $this->getHeaders($telegram_id, $locale),
                'json'    => $payload,
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (GuzzleException $e) {
            Log::error("Error saving food consumption to diary service: " . $e->getMessage());
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Показать статистику пользователя
     */
    public function showUserStats($date, $partOfDay = false, $telegram_id, $locale)
    {
        try {
            $url = $this->apiUrl . '/caloriesEndPoint/showUserStats/' . $date;
            if ($partOfDay) {
                $url .= '/' . $partOfDay;
            }

            $response = $this->client->get($url, [
                'headers' => $this->getHeaders($telegram_id, $locale),
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (GuzzleException $e) {
            Log::error("Error retrieving user stats from diary service: " . $e->getMessage());
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Удаление отдельного приёма пищи
     */
    public function deleteMeal($mealId, $telegram_id, $locale)
    {
        try {
            $response = $this->client->delete($this->apiUrl . '/caloriesEndPoint/deleteMeal/' . $mealId, [
                'headers' => $this->getHeaders($telegram_id, $locale),
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (GuzzleException $e) {
            Log::error("Error deleting meal in diary service: " . $e->getMessage());
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Проверка телеграм-кода
     */
    public function checkTelegramCode(string $code, int $telegram_id, string $locale = 'en')
    {
        try {
            $response = $this->client->post($this->apiUrl . '/caloriesEndPoint/checkTelegramCode', [
                'headers' => $this->getHeaders($telegram_id, $locale),
                'json'    => [
                    'code'        => $code,
                    'telegram_id' => $telegram_id
                ],
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (GuzzleException $e) {
            Log::error("Error verifying telegram code: " . $e->getMessage());
            return ['error' => $e->getMessage()];
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/ChatGPTService.php --- */
<?php

namespace App\Services;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\GuzzleException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use Illuminate\Support\Facades\Log;

class ChatGPTService
{
    private Client $client;
    private string $apiKey;

    public function __construct()
    {
        $this->client = new Client();
        $this->apiKey = env('OPENAI_API_KEY');
    }

    public function convertSpeechToText(string $filePath)
    {
        $multipartBody = new MultipartStream([
            [
                'name' => 'file',
                'contents' => fopen($filePath, 'r'),
                'filename' => basename($filePath)
            ],
            [
                'name' => 'model',
                'contents' => 'whisper-1'
            ]
        ]);

        $headers = [
            'Authorization' => 'Bearer ' . $this->apiKey,
            'Content-Type' => 'multipart/form-data; boundary=' . $multipartBody->getBoundary()
        ];

        $request = new Request('POST', 'https://api.openai.com/v1/audio/transcriptions', $headers, $multipartBody);

        try {
            $response = $this->client->send($request);
            $data = json_decode($response->getBody()->getContents(), true);
            if (isset($data['text'])) {
                return $this->analyzeFoodIntake($data['text']);
            }
            return false;
        } catch (GuzzleException $e) {
            return ['error' => $e->getMessage()];
        }
    }

    public function analyzeFoodIntake(string $text)
    {
        Log::info('promt: ' . $text);
        $response = $this->client->post('https://api.openai.com/v1/chat/completions', [
            'headers' => [
                'Authorization' => 'Bearer ' . $this->apiKey,
                'Content-Type' => 'application/json'
            ],
            'json' => [
                'model' => 'gpt-4o',
                'messages' => [
                    [
                        'role' => 'user',
                        'content' => "Анализируй текст: \"$text\". Выведи только список продуктов с указанием количества в граммах. Если количество не указано, используй среднестатистический вес или порцию. Формат вывода должен строго соответствовать следующему примеру, где после каждого продукта стоит точка с запятой:

Пример:
Картошка - 100 грамм;
Помидор - 120 грамм;
Курица221 - 200 грамм;

Если в тексте нет продуктов, выведи: 'продуктов нет'.

Важно:
- Все количества должны быть в граммах.
- После каждого продукта обязательно ставь точку с запятой.
- Не добавляй никакой дополнительной информации кроме списка продуктов.
- Продукт может содержать буквы и цифры (например, курица221 или курица два два один). Сохраняй полные названия продуктов без изменений.
- Убедись, что каждый продукт и его количество разделены тире и пробелами, как в примере.
- Не изменяй исходное название продукта, даже если оно содержит цифры или нестандартные символы.

Примеры входного текста и ожидаемого вывода:

1. Входной текст: 'Я съел 100 грамм картошки и помидор.'
   Ожидаемый вывод:
   Картошка - 100 грамм;
   Помидор - 120 грамм;

2. Входной текст: 'Я съел 100 грамм картошки, помидор и курица два два один.'
   Ожидаемый вывод:
   Картошка - 100 грамм;
   Помидор - 120 грамм;
   Курица221 - 200 грамм;

3. Входной текст: 'Я съел вареный картофель'
   Ожидаемый вывод:
   Вареный картофель - 200 грамм;

4. Входной текст: 'Сегодня ничего не ел.'
   Ожидаемый вывод:
   продуктов нет
"


                    ]
                ]
            ]
        ]);

        try {
            $result = json_decode($response->getBody()->getContents(), true);

            return $result['choices'][0]['message']['content'] ?? 'Не удалось извлечь данные.';
        } catch (GuzzleException $e) {
            return ['error' => $e->getMessage()];
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/AudioMessageHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers;

use App\Services\AudioConversionService;
use App\Services\ChatGPTService;
use App\Services\DiaryApiService;
use App\Services\TelegramServices\BaseHandlers\MessageHandlers\MessageHandlerInterface;
use App\Traits\BasicDataExtractor;
use App\Utilities\Utilities;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;


class AudioMessageHandler implements MessageHandlerInterface
{
    use BasicDataExtractor, EditHandlerTrait;

    protected AudioConversionService $audioConversionService;
    protected DiaryApiService $diaryApiService;
    protected ChatGPTService $chatGPTService;

    public function __construct(
        AudioConversionService $audioConversionService,
        DiaryApiService        $diaryApiService,
        ChatGPTService         $chatGPTService
    )
    {
        $this->audioConversionService = $audioConversionService;
        $this->diaryApiService = $diaryApiService;
        $this->chatGPTService = $chatGPTService;
    }

    public function handle($bot, $telegram, $message)
    {
        $commonData = self::extractCommonData($message);
        $userId = $commonData['userId'];

        $botUser = Utilities::hasCaloriesId($userId);

        if (!$botUser){
            $telegram->sendMessage([
                'chat_id' => $userId,
                'text'    => "Вы должны быть авторизированны!"
            ]);
            return;
        }

        $chatId = $commonData['chatId'];

        if (isset($message['voice'])) {

            $text = $this->audioConversionService->processAudioMessage($telegram, $bot, $message);

            if ($text) {
                Log::info('Product list: ' . $text);

                $locale = $botUser->locale;

                $responseArray = $this->diaryApiService->sendText($text, $chatId, $locale);

                if (isset($responseArray['error'])) {
                    $telegram->sendMessage([
                        'chat_id' => $chatId,
                        'text' => 'Произошла ошибка: ' . $responseArray['error']
                    ]);
                    return;
                }

                if (isset($responseArray['message']) && $responseArray['message'] === 'Products found' && !empty($responseArray['products'])) {
                    $products = $responseArray['products'];

                    $userProducts = [];

                    foreach ($products as $index => $productInfo) {

                        if (isset($productInfo['product_translation']) && isset($productInfo['product'])) {

                            $productTranslation = $productInfo['product_translation'];
                            $product = $productInfo['product'];
                            $productId = $productTranslation['id'];
                            $this->generateTableBody($product, $productTranslation, $productId);

                            $sentMessage = $telegram->sendMessage([
                                'chat_id' => $chatId,
                                'text' => $this->messageText,
                                'parse_mode' => 'Markdown',
                                'reply_markup' => $this->replyMarkup
                            ]);

                            $userProducts[$productId] = [
                                'product_translation' => $productTranslation,
                                'product' => $product,
                                'message_id' => $sentMessage->getMessageId()
                            ];

                        } else {
                            $messageText = ($index + 1) . ". Информация о продукте неполная.\n";

                            $telegram->sendMessage([
                                'chat_id' => $chatId,
                                'text' => $messageText,
                                'parse_mode' => 'Markdown'
                            ]);
                        }
                    }
                    Cache::put("user_products_{$userId}", $userProducts, now()->addMinutes(30)); // Время хранения - 30 минут

                    $finalMessageText = "Сохранить продукты на:\n";

                    $finalInlineKeyboard = [
                        [
                            [
                                'text' => 'Завтрак',
                                'callback_data' => 'save_morning'
                            ],
                            [
                                'text' => 'Oбед',
                                'callback_data' => 'save_dinner'
                            ],
                        ],
                        [
                            [
                                'text' => 'Ужин',
                                'callback_data' => 'save_supper'
                            ],
                            [
                                'text' => 'Отменить',
                                'callback_data' => 'cancel'
                            ]
                        ]
                    ];


                    $finalReplyMarkup = json_encode([
                        'inline_keyboard' => $finalInlineKeyboard
                    ]);

                    $finalMessage = $telegram->sendMessage([
                        'chat_id' => $chatId,
                        'text' => $finalMessageText,
                        'parse_mode' => 'Markdown',
                        'reply_markup' => $finalReplyMarkup
                    ]);
                    $finalMessageId = $finalMessage->getMessageId();

                    Cache::put("user_final_message_id_{$userId}", $finalMessageId, now()->addMinutes(30));
                } else {
                    $telegram->sendMessage([
                        'chat_id' => $chatId,
                        'text' => $responseArray['message'] ?? 'Продукты не найдены.'
                    ]);
                }

            } else {
                $telegram->sendMessage([
                    'chat_id' => $chatId,
                    'text' => 'Не удалось распознать аудио сообщение.'
                ]);
            }
        } else {
            $text = $message->getText() ?: 'Получено не аудио сообщение.';
            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text' => $text,
            ]);
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/CallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers;

use App\Services\TelegramServices\BaseHandlers\UpdateHandlers\UpdateHandlerInterface;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery\EditingCancelCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery\EditingSaveCallbackQueryHandler;
use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery\EditingSkipCallbackQueryHandler;
use App\Utilities\Utilities;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class CallbackQueryHandler implements UpdateHandlerInterface
{
    protected array $callbackQueryHandlers;

    public function __construct(
        CancelCallbackQueryHandler        $cancelCallbackQuery,
        SaveCallbackQueryHandler          $saveCallbackQuery,
        EditCallbackQueryHandler          $editCallbackQuery,
        DeleteCallbackQueryHandler        $deleteCallbackQuery,
        EditingSaveCallbackQueryHandler   $editingSaveCallbackQueryHandler,
        EditingCancelCallbackQueryHandler $editingCancelCallbackQueryHandler,
        EditingSkipCallbackQueryHandler   $editingSkipCallbackQueryHandler,
        SearchCallbackQueryHandler      $searchCallbackQueryHandler,
        DeleteMealCallbackQueryHandler $deleteMealCallbackQueryHandler,
    )
    {
        $this->callbackQueryHandlers = [
            'cancel' => $cancelCallbackQuery,
            'save' => $saveCallbackQuery,
            'edit' => $editCallbackQuery,
            'destroy' => $deleteCallbackQuery,
            'editing_save' => $editingSaveCallbackQueryHandler,
            'editing_cancel' => $editingCancelCallbackQueryHandler,
            'editing_skip' => $editingSkipCallbackQueryHandler,
            'search' => $searchCallbackQueryHandler,
            'delete_meal' => $deleteMealCallbackQueryHandler,
        ];
    }

    public function handle($bot, $telegram, $update)
    {
        $callbackQuery = $update->getCallbackQuery();

        $callbackData = $callbackQuery->getData();

        $userId = $callbackQuery->getFrom()->getId();

        $botUser = Utilities::hasCaloriesId($userId);

        $locale = $botUser->locale;

        if (!$botUser){
            $telegram->sendMessage([
                'chat_id' => $userId,
                'text'    => "Вы должны быть авторизированны!"
            ]);

            return;
        }

        $parts = explode('_', $callbackData);

        $action = $parts[0];
        if (isset($parts[1]) && in_array($action, ['editing', 'delete'])) {
            $action = $action . '_' . $parts[1];
        }

        if (isset($this->callbackQueryHandlers[$action])) {

            $handler = $this->callbackQueryHandlers[$action];
            $isBlocked = Cache::get("command_block{$userId}", 0);

            if (!$isBlocked || !$handler->blockAble) {

                $handler->handle($bot, $telegram, $callbackQuery, $locale);
            } else {

                $telegram->answerCallbackQuery([
                    'callback_query_id' => $callbackQuery->getId(),
                    'text' => 'Выйдите с режима редактирование(нажмите сохранить или отменить).',
                    'show_alert' => true,
                ]);
            }
            return true;
        }

        Log::info('Unknown callback query: ' . $action);
        return true;
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/CallbackQueryHandlerInterface.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers;

interface CallbackQueryHandlerInterface
{
    public function handle($bot, $telegram, $callbackQuery, $locale);
}



/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/CancelCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers;

use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class CancelCallbackQueryHandler implements CallbackQueryHandlerInterface
{
    public bool $blockAble = true;
    public function handle($bot, $telegram, $callbackQuery, $locale)
    {
        $userId = $callbackQuery->getFrom()->getId();
        $chatId = $callbackQuery->getMessage()->getChat()->getId();

        $userProducts = Cache::get("user_products_{$userId}");

        if ($userProducts && is_array($userProducts)) {
            foreach ($userProducts as $productId => $productData) {
                if (isset($productData['message_id'])) {
                    try {
                        $telegram->deleteMessage([
                            'chat_id' => $chatId,
                            'message_id' => $productData['message_id'],
                        ]);
                    } catch (\Exception $e) {
                        Log::error("Error deleting message: " . $e->getMessage());
                    }
                }
            }

            $finalMessageId = $callbackQuery->getMessage()->getMessageId();
            try {
                $telegram->deleteMessage([
                    'chat_id' => $chatId,
                    'message_id' => $finalMessageId,
                ]);
            } catch (\Exception $e) {
                Log::error("Error deleting final action message: " . $e->getMessage());
            }

            Cache::forget("user_final_message_id_{$userId}");

            Cache::forget("user_products_{$userId}");

            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text' => 'Действие отменено. Ваш список продуктов был очищен.',
            ]);

            $telegram->answerCallbackQuery([
                'callback_query_id' => $callbackQuery->getId(),
                'text' => 'Отмена выполнена',
                'show_alert' => false,
            ]);
        } else {
            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text' => 'Ваш список продуктов пуст или уже был очищен.',
            ]);

            $telegram->answerCallbackQuery([
                'callback_query_id' => $callbackQuery->getId(),
                'text' => 'Список уже пуст',
                'show_alert' => false,
            ]);
        }
    }


}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/DeleteCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers;

use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class DeleteCallbackQueryHandler implements CallbackQueryHandlerInterface
{
    public bool $blockAble = true;
    public function handle($bot, $telegram, $callbackQuery, $locale)
    {
        $callbackData = $callbackQuery->getData();
        $parts = explode('_', $callbackData);

        if (isset($parts[1])) {
            $productId = $parts[1];

            $chatId = $callbackQuery->getMessage()->getChat()->getId();
            $messageId = $callbackQuery->getMessage()->getMessageId();

            try {
                $telegram->deleteMessage([
                    'chat_id' => $chatId,
                    'message_id' => $messageId,
                ]);
            } catch (\Exception $e) {
                Log::error("Error deleting product message: " . $e->getMessage());
            }

            $userId = $callbackQuery->getFrom()->getId();

            $products = Cache::get("user_products_{$userId}", []);

            if (isset($products[$productId])) {
                unset($products[$productId]);

                if (count($products) > 0) {
                    Cache::put("user_products_{$userId}", $products, now()->addMinutes(30));
                } else {
                    Cache::forget("user_products_{$userId}");

                    $finalMessageId = Cache::get("user_final_message_id_{$userId}");

                    if ($finalMessageId) {
                        try {
                            $telegram->deleteMessage([
                                'chat_id' => $chatId,
                                'message_id' => $finalMessageId,
                            ]);
                        } catch (\Exception $e) {
                            Log::error("Error deleting final action message: " . $e->getMessage());
                        }

                        Cache::forget("user_final_message_id_{$userId}");
                    }
                }

                $telegram->answerCallbackQuery([
                    'callback_query_id' => $callbackQuery->getId(),
                    'text' => 'Продукт удалён из списка.',
                    'show_alert' => false,
                ]);
            }
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/DeleteMealCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers;

use App\Services\DiaryApiService;
use Illuminate\Support\Facades\Log;

class DeleteMealCallbackQueryHandler implements CallbackQueryHandlerInterface
{
    public bool $blockAble = true;

    protected DiaryApiService $diaryApiService;

    public function __construct(DiaryApiService $diaryApiService)
    {
        $this->diaryApiService = $diaryApiService;
    }

    public function handle($bot, $telegram, $callbackQuery, $locale)
    {
        $callbackData = $callbackQuery->getData();
        $parts = explode('_', $callbackData);

        if (isset($parts[2])) {
            $mealId = $parts[2];

            $chatId = $callbackQuery->getMessage()->getChat()->getId();
            $messageId = $callbackQuery->getMessage()->getMessageId();

            // Отправляем запрос на удаление продукта в дневнике
            Log::info('try');
            $response = $this->diaryApiService->deleteMeal($mealId, $chatId, $locale);
            Log::info($response);
            if (isset($response['error'])) {
                Log::error('Error deleting meal: ' . $response['error']);
                $telegram->answerCallbackQuery([
                    'callback_query_id' => $callbackQuery->getId(),
                    'text' => 'Ошибка при удалении продукта.',
                    'show_alert' => true,
                ]);
            } else {
                // Удаляем сообщение с продуктом
                try {
                    $telegram->deleteMessage([
                        'chat_id' => $chatId,
                        'message_id' => $messageId,
                    ]);
                } catch (\Exception $e) {
                    Log::error("Error deleting meal message: " . $e->getMessage());
                }

                $telegram->answerCallbackQuery([
                    'callback_query_id' => $callbackQuery->getId(),
                    'text' => 'Продукт удалён.',
                    'show_alert' => false,
                ]);
            }
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/EditCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers;

use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class EditCallbackQueryHandler implements CallbackQueryHandlerInterface
{
    public bool $blockAble = true;
    public function handle($bot, $telegram, $callbackQuery, $locale)
    {
        $callbackData = $callbackQuery->getData();
        $parts = explode('_', $callbackData);

        if (isset($parts[1])) {
            $productId = $parts[1];

            $userId = $callbackQuery->getFrom()->getId();
            $chatId = $callbackQuery->getMessage()->getChat()->getId();


            $userProducts = Cache::get("user_products_{$userId}");

//            Log::info('$userProducts: ');
//            Log::info(print_r($userProducts, true));

            if ($userProducts && isset($userProducts[$productId])) {
                $productData = $userProducts[$productId];

                $replyMarkup = json_encode([
                    'inline_keyboard' => [
                        [
                            ['text' => 'Сохранить', 'callback_data' => 'editing_save'],
                            ['text' => 'Пропустить шаг', 'callback_data' => 'editing_skip'],
                            ['text' => 'Отменить', 'callback_data' => 'editing_cancel'],
                        ]
                    ]
                ]);

                $sentMessage = $telegram->sendMessage([
                    'chat_id' => $chatId,
                    'text' => "Вы редактируете продукт: *{$productData['product_translation']['name']}*\n\nПожалуйста, введите новое название продукта.",
                    'reply_markup' => $replyMarkup,
                ]);

                Cache::put("user_editing_{$userId}", [
                    'product_id' => $productId,
                    'step' => 'awaiting_name',
                    'message_id' => $sentMessage->getMessageId(),
                    'original_product' => $productData,
                ], now()->addMinutes(30));

                Cache::put("command_block{$userId}", 1,  now()->addMinutes(30));

                $telegram->answerCallbackQuery([
                    'callback_query_id' => $callbackQuery->getId(),
                ]);
            } else {
                $telegram->answerCallbackQuery([
                    'callback_query_id' => $callbackQuery->getId(),
                    'text' => 'Продукт не найден или истекло время сессии.',
                    'show_alert' => true,
                ]);
            }
        } else {
            $telegram->answerCallbackQuery([
                'callback_query_id' => $callbackQuery->getId(),
                'text' => 'Некорректный запрос.',
                'show_alert' => true,
            ]);
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/EditingProcessCallbackQuery/EditingBaseCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery;

use App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\CallbackQueryHandlerInterface;
use App\Services\TelegramServices\CaloriesHandlers\EditHandlerTrait;
use Illuminate\Support\Facades\Cache;

class EditingBaseCallbackQueryHandler implements CallbackQueryHandlerInterface
{
    use EditHandlerTrait;
    public bool $blockAble = false;
    protected $callbackData;
    protected $userId;
    protected $chatId;
    protected $messageId;
    protected $productId;
    protected $userProducts;
    protected $editingState;

    public function handle($bot, $telegram, $callbackQuery, $locale)
    {
        if (!$this->initialize($telegram, $callbackQuery)) {
            return;
        }

        $this->process($bot, $telegram, $callbackQuery);
    }

    protected function initialize($telegram, $callbackQuery)
    {
        $this->callbackData = $callbackQuery->getData();
        $this->userId = $callbackQuery->getFrom()->getId();
        $this->chatId = $callbackQuery->getMessage()->getChat()->getId();
        $this->messageId = $callbackQuery->getMessage()->getMessageId();

        $this->editingState = Cache::get("user_editing_{$this->userId}");

        if (!$this->editingState) {
            $telegram->answerCallbackQuery([
                'callback_query_id' => $callbackQuery->getId(),
                'text' => 'Сессия редактирования истекла или отсутствует.',
                'show_alert' => true,
            ]);
            return false;
        }

        $this->productId = $this->editingState['product_id'];

        $this->userProducts = Cache::get("user_products_{$this->userId}");

        if (!$this->userProducts || !isset($this->userProducts[$this->productId])) {
            $this->clearEditingState($this->userId);
            $telegram->answerCallbackQuery([
                'callback_query_id' => $callbackQuery->getId(),
                'text' => 'Продукт не найден или истекло время сессии.',
                'show_alert' => true,
            ]);
            return false;
        }

        return true;
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/EditingProcessCallbackQuery/EditingCancelCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery;

class EditingCancelCallbackQueryHandler extends EditingBaseCallbackQueryHandler
{
    protected function process($bot, $telegram, $callbackQuery)
    {
        $this->exitEditing(
            $telegram,
            $this->chatId,
            $this->userId,
            $this->userProducts,
            $this->productId,
            $this->messageId,
            $callbackQuery->getId()
        );

        $telegram->answerCallbackQuery([
            'callback_query_id' => $callbackQuery->getId(),
            'text' => 'Редактирование отменено.',
            'show_alert' => false,
        ]);
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/EditingProcessCallbackQuery/EditingSaveCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery;

class EditingSaveCallbackQueryHandler extends EditingBaseCallbackQueryHandler
{
    protected function process($bot, $telegram, $callbackQuery)
    {
        $this->saveEditing(
            $telegram,
            $this->chatId,
            $this->userId,
            $this->userProducts,
            $this->productId,
            $this->messageId,
            $callbackQuery->getId()
        );
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/EditingProcessCallbackQuery/EditingSkipCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers\EditingProcessCallbackQuery;

use Illuminate\Support\Facades\Cache;

class EditingSkipCallbackQueryHandler extends EditingBaseCallbackQueryHandler
{
    protected function process($bot, $telegram, $callbackQuery)
    {

        $this->processSkip($telegram, $this->chatId, $this->userId, $this->editingState, $this->userProducts, $this->productId, $this->messageId);

        $telegram->answerCallbackQuery([
            'callback_query_id' => $callbackQuery->getId(),
            'text' => 'Шаг пропущен.',
            'show_alert' => false,
        ]);
    }

    protected function processSkip($telegram, $chatId, $userId, &$editingState, &$userProducts, $productId, $messageId)
    {
        switch ($editingState['step']) {
            case 'awaiting_name':
                $editingState['step'] = 'awaiting_quantity';
                $nextPrompt = 'Пожалуйста, введите новое количество грамм.';
                break;
            case 'awaiting_quantity':
                $editingState['step'] = 'awaiting_calories';
                $nextPrompt = 'Пожалуйста, введите новое количество калорий.';
                break;
            case 'awaiting_calories':
                $editingState['step'] = 'awaiting_proteins';
                $nextPrompt = 'Пожалуйста, введите новое количество белков.';
                break;
            case 'awaiting_proteins':
                $editingState['step'] = 'awaiting_fats';
                $nextPrompt = 'Пожалуйста, введите новое количество жиров.';
                break;
            case 'awaiting_fats':
                $editingState['step'] = 'awaiting_carbohydrates';
                $nextPrompt = 'Пожалуйста, введите новое количество углеводов.';
                break;
            case 'awaiting_carbohydrates':
                $this->saveEditing($telegram, $chatId, $userId, $userProducts, $productId, $messageId);
                return;
            default:
                $this->clearEditingState($userId);
                $telegram->sendMessage([
                    'chat_id' => $chatId,
                    'text' => 'Произошла ошибка при редактировании продукта.',
                ]);
                return;
        }

        Cache::put("user_editing_{$userId}", $editingState, now()->addMinutes(30));

        $this->editEditingMessage($telegram, $chatId, $messageId, $nextPrompt);
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/SaveCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers;

use App\Utilities\Utilities;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;
use App\Services\DiaryApiService;

class SaveCallbackQueryHandler implements CallbackQueryHandlerInterface
{
    public bool $blockAble = true;
    protected DiaryApiService $diaryApiService;

    public function __construct()
    {
        $this->diaryApiService = new DiaryApiService();
    }

    public function handle($bot, $telegram, $callbackQuery, $locale)
    {
        $userId = $callbackQuery->getFrom()->getId();
        $chatId = $callbackQuery->getMessage()->getChat()->getId();
        $callbackData = $callbackQuery->getData();

        $parts = explode('_', $callbackData);

        if(count($parts) > 1){
            $partOfTheDay = $parts[1];
        }

        $data = Cache::get("user_products_{$userId}");
        if (!$data){
            return;
        }
        $diaryUserId = 32;
        $total = [
            'calories' => 0,
            'proteins' => 0,
            'fats' => 0,
            'carbohydrates' => 0,
        ];

        foreach ($data as $productData) {
            $product = $productData['product'];
            $productTranslation = $productData['product_translation'];

            $total['calories'] += round($product['calories'] * $product['quantity_grams'] / 100);
            $total['proteins'] += round($product['proteins'] * $product['quantity_grams'] / 100);
            $total['fats'] += round($product['fats'] * $product['quantity_grams'] / 100);
            $total['carbohydrates'] += round($product['carbohydrates'] * $product['quantity_grams'] / 100);

            if (isset($product['edited']) && $product['edited'] == 1) {
                $this->saveProduct($product, $productTranslation, $diaryUserId, $partOfTheDay, $chatId, $locale);
            } else {
                $this->saveFoodConsumption($product, $diaryUserId, $partOfTheDay, $chatId, $locale);
            }
//            Log::info('before deleting');
//            Log::info("product_click_count_{$userId}_{$productTranslation['id']}");
            Cache::forget("product_click_count_{$userId}_{$productTranslation['id']}");
        }

        $productArray = [
            [ "Калории", $total['calories']],
            [ "Белки",$total['proteins']],
            [ "Жиры", $total['fats']],
            [ "Углеводы", $total['carbohydrates']],
        ];
        $messageText = Utilities::generateTableType2('Данные сохранены, Вы употребили' , $productArray) . "\n\n";

        Cache::forget("user_products_{$userId}");
        Cache::forget("user_final_message_id_{$userId}");

        $telegram->sendMessage([
            'chat_id' => $chatId,
            'text' => $messageText,
            'parse_mode' => 'Markdown',

        ]);

        $this->deleteProductMessages($telegram, $chatId, $data, $callbackQuery);

        $telegram->answerCallbackQuery([
            'callback_query_id' => $callbackQuery->getId(),
        ]);
    }

    protected function saveProduct($product, $productTranslation, $diaryUserId, $partOfTheDay,$chat_id, $locale)
    {
        $postData = [
            'user_id' => $diaryUserId,
            'name' => $productTranslation['name'],
            'calories' => $product['calories_per_100g'] ?? $product['calories'],
            'carbohydrates' => $product['carbohydrates_per_100g'] ?? $product['carbohydrates'],
            'fats' => $product['fats_per_100g'] ?? $product['fats'],
            'fibers' => $product['fibers_per_100g'] ?? $product['fibers'] ?? 0,
            'proteins' => $product['proteins_per_100g'] ?? $product['proteins'],
            'quantity' => $product['quantity_grams'],
            'consumed_at' => date('Y-m-d'),
//            'consumed_at' =>  date('Y-m-d', strtotime('-1 day')),
            'part_of_day' => $partOfTheDay,
        ];

        $response = $this->diaryApiService->saveProduct($postData,$chat_id, $locale);

        if (isset($response['error'])) {
            Log::error('Error saving product: ' . $response['error']);
        } else {
            Log::info('Product saved successfully.');
        }
    }

    protected function saveFoodConsumption($product, $diaryUserId, $partOfTheDay, $chat_id, $locale)
    {


        $postData = [
            'user_id'      => $diaryUserId,
            'food_id'      => $product['id'],
            'quantity'     => $product['quantity_grams'],
            'consumed_at'  => date('Y-m-d'),
//            'consumed_at' =>  date('Y-m-d', strtotime('-1 day')),
            'part_of_day'  => $partOfTheDay,
        ];


        $response = $this->diaryApiService->saveFoodConsumption($postData, $chat_id, $locale);

        if (isset($response['error'])) {
            Log::error('Error saving food consumption: ' . $response['error']);
        } else {
            Log::info('Food consumption saved successfully.');
        }
    }

    protected function deleteProductMessages($telegram, $chatId, $data, $callbackQuery)
    {
        foreach ($data as $productData) {
            if (isset($productData['message_id'])) {
                try {
                    $telegram->deleteMessage([
                        'chat_id' => $chatId,
                        'message_id' => $productData['message_id'],
                    ]);
                } catch (\Exception $e) {
                    Log::error("Error deleting product message: " . $e->getMessage());
                }
            }
        }

        $finalMessageId = $callbackQuery->getMessage()->getMessageId();
        try {
            $telegram->deleteMessage([
                'chat_id' => $chatId,
                'message_id' => $finalMessageId,
            ]);
        } catch (\Exception $e) {
            Log::error("Error deleting final action message: " . $e->getMessage());
        }
    }
    private function getPartOfTheDay(): string
    {

        $currentHour = (int)date('G');

        if ($currentHour >= 6 && $currentHour < 12) {
            $partOfDay = 'morning';
        } elseif ($currentHour >= 12 && $currentHour < 18) {
            $partOfDay = 'dinner';
        } else {
            $partOfDay = 'supper';
        }
        return $partOfDay;
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/CallbackQueryHandlers/SearchCallbackQueryHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\CallbackQueryHandlers;

use App\Services\ChatGPTServices\SpeechToTextService;
use App\Services\DiaryApiService;
use App\Services\TelegramServices\CaloriesHandlers\EditHandlerTrait;
use GuzzleHttp\Exception\GuzzleException;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class SearchCallbackQueryHandler implements CallbackQueryHandlerInterface
{
    public bool $blockAble = true;

    use EditHandlerTrait;

    protected DiaryApiService $diaryApiService;
    protected SpeechToTextService $speechToTextService;

    public function __construct(DiaryApiService $diaryApiService, SpeechToTextService $speechToTextService)
    {
        $this->diaryApiService = $diaryApiService;
        $this->speechToTextService = $speechToTextService;
    }

    public function handle($bot, $telegram, $callbackQuery, $locale)
    {
        $callbackData = $callbackQuery->getData();
        $parts = explode('_', $callbackData);
        $messageId = $callbackQuery->getMessage()->getMessageId();

        if (isset($parts[1])) {
            $productId = $parts[1];
            $chatId = $callbackQuery->getMessage()->getChat()->getId();
            $userId = $callbackQuery->getFrom()->getId();

            $products = Cache::get("user_products_{$userId}", []);

            if (isset($products[$productId])) {
//                Log::info('before searching');
//                Log::info("product_click_count_{$userId}_{$productId}");
                $clickCount = Cache::increment("product_click_count_{$userId}_{$productId}");
                Cache::put("product_click_count_{$userId}_{$productId}", $clickCount, now()->addMinutes(30));

                $saidName = $products[$productId]['product_translation']['said_name'];
                $quantityGrams = $products[$productId]['product']['quantity_grams'] ?? '';
                $originalName = $products[$productId]['product_translation']['original_name'] ?? '';
                $formattedText = $saidName . " - " . $quantityGrams . " грамм";

                try {
//                    Log::info('$clickCount');
//                    Log::info($clickCount);
                    if ($clickCount > 1) {
//                        Log::info('generating, $clickCount > 1');
                        $this->generateProductData($products, $productId, $userId, $telegram, $chatId, $callbackQuery);
                    } else {
//                        Log::info('$saidName != $originalName');
//                        Log::info($saidName. ', ' . $originalName);
                        if ($saidName != $originalName) {
                            $response = $this->diaryApiService->getTheMostRelevantProduct($formattedText,$chatId, $locale);
//                            Log::info('$response');
//                            Log::info(print_r($response, true));
                            if (isset($response['product'])) {
                                $product = $response['product'];
                            } else {
//                                Log::info('generating, product not found');
                                $this->generateProductData($products, $productId, $userId, $telegram, $chatId, $callbackQuery);
                                return;
                            }
                        } else {
//                            Log::info('generating, $saidName !== $originalName');
                            $this->generateProductData($products, $productId, $userId, $telegram, $chatId, $callbackQuery);
                            return;
                        }
                    }
                } catch (GuzzleException $e) {
                    Log::error("Error generating product data: " . $e->getMessage());
                    $telegram->answerCallbackQuery([
                        'callback_query_id' => $callbackQuery->getId(),
                        'text' => 'Произошла ошибка при обработке данных.',
                        'show_alert' => false,
                    ]);
                    return;
                }

                if (isset($product)) {
//                    Log::info('Product after search:', $product);

                    unset($products[$productId]);
                    $newProductId = $product['product_translation']['id'] ?? $productId;

                    $products[$newProductId] = $product;
                    $products[$newProductId]['message_id'] = $messageId;

                    Cache::put("user_products_{$userId}", $products, now()->addMinutes(30));

                    $this->updateProductMessage($telegram, $chatId, $products[$newProductId]);

                    $telegram->answerCallbackQuery([
                        'callback_query_id' => $callbackQuery->getId(),
                        'text' => 'Данные продукта обновлены.',
                        'show_alert' => false,
                    ]);
                } else {
                    $telegram->answerCallbackQuery([
                        'callback_query_id' => $callbackQuery->getId(),
                        'text' => 'Продукт не найден.',
                        'show_alert' => false,
                    ]);
                }
            }
        }
    }

    private function generateProductData(&$products, $productId, $userId, $telegram, $chatId, $callbackQuery)
    {
        $saidName = $products[$productId]['product_translation']['said_name'];

        try {
            Log::info('saidName: ' . $saidName);
            $productData = $this->speechToTextService->generateNewProductData($saidName);
            Log::info('generated: ');
            Log::info(print_r($productData, true));
        } catch (GuzzleException $e) {
            Log::error("Error generating product data: " . $e->getMessage());
            $telegram->answerCallbackQuery([
                'callback_query_id' => $callbackQuery->getId(),
                'text' => 'Произошла ошибка генерации данных.',
                'show_alert' => false,
            ]);
            return;
        }

        if ($productData) {
            $newNutritionalData = $this->parseNutritionalData($productData);

            if (isset($products[$productId]['product'])) {
                foreach ($newNutritionalData as $key => $value) {
                    $products[$productId]['product'][$key] = $value;
                }
            }

            $products[$productId]['product']['edited'] = 1;
            $products[$productId]['product_translation']['name'] = $saidName;

            Cache::put("user_products_{$userId}", $products, now()->addMinutes(30));

            $this->updateProductMessage($telegram, $chatId, $products[$productId]);

            $telegram->answerCallbackQuery([
                'callback_query_id' => $callbackQuery->getId(),
                'text' => 'Данные продукта обновлены.',
                'show_alert' => false,
            ]);
        } else {
            $telegram->answerCallbackQuery([
                'callback_query_id' => $callbackQuery->getId(),
                'text' => 'Не удалось получить данные продукта.',
                'show_alert' => false,
            ]);
        }
    }

    private function parseNutritionalData($dataString): array
    {
        $nutritionalData = [];
        $parts = explode(';', $dataString);

        foreach ($parts as $part) {
            $part = trim($part, " ;");
            if (empty($part)) continue;

            $keyValue = explode('-', $part);
            if (count($keyValue) === 2) {
                $key = trim($keyValue[0]);
                $value = trim($keyValue[1]);

                switch (mb_strtolower($key)) {
                    case 'калории':
                        $nutritionalData['calories'] = (float)$value;
                        break;
                    case 'белки':
                        $nutritionalData['proteins'] = (float)$value;
                        break;
                    case 'жиры':
                        $nutritionalData['fats'] = (float)$value;
                        break;
                    case 'углеводы':
                        $nutritionalData['carbohydrates'] = (float)$value;
                        break;
                }
            }
        }

        return $nutritionalData;
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/EditHandlerTrait.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers;

use App\Utilities\Utilities;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

trait EditHandlerTrait
{
    protected $messageText;
    protected $replyMarkup;
    protected function saveEditing($telegram, $chatId, $userId, &$userProducts, $productId, $messageId, $callbackQueryId = false)
    {
        $this->updateProductMessage($telegram, $chatId, $userProducts[$productId]);

        if($callbackQueryId){
            $telegram->answerCallbackQuery([
            'callback_query_id' => $callbackQueryId,
            'text' => 'Изменения сохранены.',
            'show_alert' => false,
        ]);}

        $this->deleteEditingMessage($telegram, $chatId, $messageId);

        $this->clearEditingState($userId);
    }

    protected function exitEditing($telegram, $chatId, $userId, &$userProducts, $productId, $messageId, $callbackQueryId = false)
    {
        $editingState = Cache::get("user_editing_{$userId}");
        if (isset($editingState['original_product'])) {
            $userProducts[$productId] = $editingState['original_product'];
            Cache::put("user_products_{$userId}", $userProducts, now()->addMinutes(30));
        }

        $this->updateProductMessage($telegram, $chatId, $userProducts[$productId]);

        if($callbackQueryId){
            $telegram->answerCallbackQuery([
                'callback_query_id' => $callbackQueryId,
                'text' => 'Изменения отменены',
                'show_alert' => false,
            ]);}
        $this->deleteEditingMessage($telegram, $chatId, $messageId);

        $this->clearEditingState($userId);
    }

    protected function clearEditingState($userId)
    {
        Cache::forget("user_editing_{$userId}");
        Cache::forget("command_block{$userId}", 0);
    }

    protected function updateProductMessage($telegram, $chatId, $productData)
    {
        Log::info(print_r($productData, true));
        $messageId = $productData['message_id'];


        $productTranslation = $productData['product_translation'];
        $product = $productData['product'];
        $productId = $productTranslation['id'];

        $this->generateTableBody($product, $productTranslation,$productId);

        try {
            $telegram->editMessageText([
                'chat_id' => $chatId,
                'message_id' => $messageId,
                'text' => $this->messageText,
                'parse_mode' => 'Markdown',
                'reply_markup' => $this->replyMarkup,
            ]);
        } catch (\Telegram\Bot\Exceptions\TelegramResponseException $e) {
            $errorData = $e->getResponseData();
            if (isset($errorData['description']) && strpos($errorData['description'], 'message is not modified') !== false) {
                Log::info('Сообщение не изменилось, обновление не требуется.');
            } else {
                Log::error("Error updating product message: " . $e->getMessage());
            }
        } catch (\Exception $e) {
            Log::error("Error updating product message: " . $e->getMessage());
        }
    }

    protected function deleteEditingMessage($telegram, $chatId, $messageId)
    {
        try {
            $telegram->deleteMessage([
                'chat_id' => $chatId,
                'message_id' => $messageId,
            ]);
        } catch (\Exception $e) {
            Log::error("Error deleting editing message: " . $e->getMessage());
        }
    }

    protected function editEditingMessage($telegram, $chatId, $messageId, $newText)
    {
        $replyMarkup = json_encode([
            'inline_keyboard' => [
                [
                    ['text' => 'Сохранить', 'callback_data' => 'editing_save'],
                    ['text' => 'Пропустить шаг', 'callback_data' => 'editing_skip'],
                    ['text' => 'Отменить', 'callback_data' => 'editing_cancel'],
                ]
            ]
        ]);

        try {
            $telegram->editMessageText([
                'chat_id' => $chatId,
                'message_id' => $messageId,
                'text' => $newText,
                'reply_markup' => $replyMarkup,
            ]);
        } catch (\Exception $e) {
            Log::error("Error editing message during editing: " . $e->getMessage());
        }
    }

    protected function generateTableBody($product, $productTranslation, $productId){

        $productArray = [
            [ "Калории", $product['calories'],round($product['calories']/100*$product['quantity_grams'] ,1)],
            [ "Белки", $product['proteins'],round($product['proteins']/100*$product['quantity_grams'] ,1)],
            [ "Жиры", $product['fats'],round($product['fats']/100*$product['quantity_grams'] ,1)],
            [ "Углеводы", $product['carbohydrates'],round($product['carbohydrates']/100*$product['quantity_grams'] ,1)],
        ];


        $this->messageText = Utilities::generateTable($productTranslation['name'] ,$product['quantity_grams'], $productArray , $productTranslation['said_name']);

        $inlineKeyboard = [
            [
                [
                    'text' => 'Искать',
                    'callback_data' => 'search_' . $productId
                ],
            ],
            [
                [
                    'text' => 'Изменить',
                    'callback_data' => 'edit_' . $productId
                ],
                [
                    'text' => 'Удалить',
                    'callback_data' => 'destroy_' . $productId
                ]
            ]
        ];
        $this->replyMarkup = json_encode([
            'inline_keyboard' => $inlineKeyboard
        ]);
        return true;
    }
 }


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/TextMessageHandlers/EditMessageHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\TextMessageHandlers;

use App\Services\TelegramServices\BaseHandlers\MessageHandlers\MessageHandlerInterface;
use App\Services\TelegramServices\CaloriesHandlers\EditHandlerTrait;
use App\Utilities\Utilities;
use Illuminate\Support\Facades\Cache;

class EditMessageHandler implements MessageHandlerInterface
{
    use EditHandlerTrait;

    public function handle($bot, $telegram, $message)
    {
        $userId = $message->getFrom()->getId();
        $chatId = $message->getChat()->getId();

        $botUser = Utilities::hasCaloriesId($userId);

        if (!$botUser){
            $telegram->sendMessage([
                'chat_id' => $userId,
                'text'    => "Вы должны быть авторизированны!"
            ]);
            return;
        }

        $text = $message->getText();

        $editingState = Cache::get("user_editing_{$userId}");

        if ($editingState) {
            $productId = $editingState['product_id'];
            $step = $editingState['step'];
            $messageId = $editingState['message_id'];

            $userProducts = Cache::get("user_products_{$userId}");

            if (!$userProducts || !isset($userProducts[$productId])) {
                $this->clearEditingState($userId);

                $telegram->sendMessage([
                    'chat_id' => $chatId,
                    'text' => 'Продукт не найден или истекло время сессии.',
                ]);

                return;
            }

            $productData = $userProducts[$productId];

            $this->processInput($telegram, $chatId, $userId, $text, $editingState, $userProducts, $productId, $messageId);


            $this->deleteUserMessage($telegram, $chatId, $message->getMessageId());

            return;
        } else {
            return;
        }
    }

    protected function processInput($telegram, $chatId, $userId, $text, &$editingState, &$userProducts, $productId, $messageId)
    {
        $currentStep = $editingState['step'];
        $validInput = true;

        switch ($currentStep) {
            case 'awaiting_name':
                if (strlen($text) <= 50){
                $userProducts[$productId]['product_translation']['name'] = $text;
                $userProducts[$productId]['product_translation']['said_name'] = $text;
                $userProducts[$productId]['product']['edited'] = 1;
                Cache::forget("product_click_count_{$userId}_{$productId}");
                $nextStep = 'awaiting_quantity';
                $nextPrompt = 'Пожалуйста, введите новое количество грамм.';
                } else {
                    $validInput = false;
                    $errorMessage = 'Значение слишком длинное';
                }
                break;
            case 'awaiting_quantity':
                if (is_numeric($text) && $text > -1 && $text <= 1250) {
                    $userProducts[$productId]['product']['quantity_grams'] = $text;
                    $nextStep = 'awaiting_calories';
                    $nextPrompt = 'Пожалуйста, введите новое количество калорий.';
                } else {
                    $validInput = false;
                    $errorMessage = 'Пожалуйста, введите корректное числовое значение для грамм.';
                    }
                break;
            case 'awaiting_calories':
                if (is_numeric($text) && $text > -1 && $text <= 1250) {
                    $userProducts[$productId]['product']['calories'] = $text;
                    $userProducts[$productId]['product']['edited'] = 1;
                    $nextStep = 'awaiting_proteins';
                    $nextPrompt = 'Пожалуйста, введите новое количество белков.';
                } else {
                    $validInput = false;
                    $errorMessage = 'Пожалуйста, введите корректное числовое значение для калорий.';
                }
                break;
            case 'awaiting_proteins':
                if (is_numeric($text) && $text > -1 && $text <= 1250) {
                    $userProducts[$productId]['product']['proteins'] = $text;
                    $userProducts[$productId]['product']['edited'] = 1;
                    $nextStep = 'awaiting_fats';
                    $nextPrompt = 'Пожалуйста, введите новое количество жиров.';
                } else {
                    $validInput = false;
                    $errorMessage = 'Пожалуйста, введите корректное числовое значение для белков.';
                }
                break;
            case 'awaiting_fats':
                if (is_numeric($text) && $text > -1 && $text <= 1250) {
                    $userProducts[$productId]['product']['fats'] = $text;
                    $userProducts[$productId]['product']['edited'] = 1;
                    $nextStep = 'awaiting_carbohydrates';
                    $nextPrompt = 'Пожалуйста, введите новое количество углеводов.';
                } else {
                    $validInput = false;
                    $errorMessage = 'Пожалуйста, введите корректное числовое значение для жиров.';
                }
                break;
            case 'awaiting_carbohydrates':
                if (is_numeric($text) && $text > -1 && $text <= 1250) {
                    $userProducts[$productId]['product']['carbohydrates'] = $text;
                    $userProducts[$productId]['product']['edited'] = 1;

                    $this->saveEditing($telegram, $chatId, $userId, $userProducts, $productId, $messageId);
                    Cache::put("user_products_{$userId}", $userProducts, now()->addMinutes(30));
                    return;
                } else {
                    $validInput = false;
                    $errorMessage = 'Пожалуйста, введите корректное числовое значение для углеводов.';
                }
                break;
            default:
                $this->clearEditingState($userId);
                $telegram->sendMessage([
                    'chat_id' => $chatId,
                    'text' => 'Произошла ошибка при редактировании продукта.',
                ]);
                return;
        }

        if ($validInput) {
            Cache::put("user_products_{$userId}", $userProducts, now()->addMinutes(30));

            $editingState['step'] = $nextStep;
            Cache::put("user_editing_{$userId}", $editingState, now()->addMinutes(30));

            $this->updateProductMessage($telegram, $chatId, $userProducts[$productId]);

            $this->editEditingMessage($telegram, $chatId, $messageId, $nextPrompt);
        } else {
            $this->editEditingMessage($telegram, $chatId, $messageId, $errorMessage);
        }
    }

    protected function deleteUserMessage($telegram, $chatId, $messageId)
    {
        // В личных чатах бот не может удалять сообщения пользователя
        // Если бот в группе и является администратором с правами удаления сообщений, то можно попытаться удалить
        try {
            $telegram->deleteMessage([
                'chat_id' => $chatId,
                'message_id' => $messageId,
            ]);
        } catch (\Exception $e) {
        }
    }

}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/TextMessageHandlers/LanguageMessageHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\TextMessageHandlers;

use App\Models\BotUser;
use App\Services\TelegramServices\BaseHandlers\TextMessageHandlers\Telegram;
use App\Traits\BasicDataExtractor;
use App\Utilities\Utilities;
use Illuminate\Support\Facades\Log;
use Telegram\Bot\Keyboard\Keyboard;

class LanguageMessageHandler
{
    use BasicDataExtractor;

    public function handle($bot, $telegram, $message)
    {
        $text = $message->getText();

        $commonData = self::extractCommonData($message);
        $chatId     = $commonData['chatId'];

        $botUser = BotUser::where('telegram_id', $chatId)->first();

        if ($text === '/language') {
            $keyboard = Keyboard::make([
                'keyboard'          => [
                    ['English', 'Русский', 'Українська'],
                ],
                'resize_keyboard'   => true,
                'one_time_keyboard' => true,
            ]);

            $telegram->sendMessage([
                'chat_id'      => $chatId,
                'text'         => "Please choose your language / Пожалуйста, выберите язык / Будь ласка, оберіть мову",
                'reply_markup' => $keyboard
            ]);
            return;
        }

        if ($text === 'English') {
            if ($botUser) {
                $botUser->locale = 'en';
                $botUser->save();
            }

            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text'    => "Your language has been set to English."
            ]);
            return;
        }

        if ($text === 'Русский') {
            Log::info(11111);
            if ($botUser) {
                $botUser->locale = 'ru';
                $botUser->save();
            }

            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text'    => "Ваш язык установлен на русский."
            ]);
            return;
        }

        if ($text === 'Українська') {
            if ($botUser) {
                $botUser->locale = 'uk';
                $botUser->save();
            }

            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text'    => "Ваша мова встановлена на українську."
            ]);
            return;
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/TextMessageHandlers/StartMessageHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\TextMessageHandlers;

use App\Models\BotUser;
use App\Services\DiaryApiService;
use App\Services\TelegramServices\BaseHandlers\TextMessageHandlers\Telegram;
use App\Traits\BasicDataExtractor;
use App\Utilities\Utilities;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Telegram\Bot\FileUpload\InputFile;
use Telegram\Bot\Keyboard\Keyboard;

class StartMessageHandler
{
    use BasicDataExtractor;

    protected DiaryApiService $diaryApiService;

    public function __construct(DiaryApiService $diaryApiService)
    {
        $this->diaryApiService = $diaryApiService;
    }

    public function handle($bot, $telegram, $message)
    {
        $text = $message->getText();

        if (!str_starts_with($text, '/start')) {
            return;
        }

        $commonData = self::extractCommonData($message);
        $chatId = $commonData['chatId'];

        $botUser = Utilities::hasCaloriesId($chatId);

//        if (!$botUser){
//            $telegram->sendMessage([
//                'chat_id' => $chatId,
//                'text'    => "Вы должны быть авторизированны!"
//            ]);
//            return;
//        }


        $parts = explode(' ', $text);
        $code = $parts[1] ?? null;

        if ($code) {
            $result = $this->diaryApiService->checkTelegramCode($code, $chatId);

            if (!empty($result['success']) && $result['success'] === true) {
                $caloriesUserId = $result['user_id'];

                $botUser = Utilities::saveAndNotify(
                    $commonData['chatId'],
                    $commonData['firstName'],
                    $commonData['lastName'],
                    $commonData['username'],
                    $bot,
                    $commonData['premium']
                );

                $botUser->calories_id = $caloriesUserId;
                $botUser->save();

                Log::info("User {$chatId} linked with calories ID {$caloriesUserId}");

                $this->sendWelcome($bot, $telegram, $message, $commonData);
                return;
            } else {
                $telegram->sendMessage([
                    'chat_id' => $chatId,
                    'text'    => "Код недействителен или уже использован. Пожалуйста, зарегистрируйтесь заново."
                ]);
                return;
            }
        }

        if ($botUser) {
            $this->sendWelcome($bot, $telegram, $message, $commonData);

            Utilities::saveAndNotify(
                $commonData['chatId'],
                $commonData['firstName'],
                $commonData['lastName'],
                $commonData['username'],
                $bot,
                $commonData['premium']
            );
        } else {
            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text'    => "Похоже, вы здесь впервые. Чтобы связать аккаунт, используйте ссылку «Подключить» из личного кабинета (на сайте)."
            ]);
        }
    }

    /**
     * Отправка «приветственного» сообщения (с картинкой/клавиатурой).
     * Вынесена в отдельный метод, чтобы переиспользовать в разных условиях.
     */
    protected function sendWelcome($bot, $telegram, $message, array $commonData): void
    {
        $imagePath = $bot->message_image;
        $messageText = $bot->message;

        // Формируем клавиатуру
        $keyboard = Keyboard::make([
            'resize_keyboard' => true,
        ])->row([
            ['text' => '/stats_morning'],
            ['text' => '/stats_dinner']
        ])->row([
            ['text' => '/stats_supper'],
            ['text' => '/stats']
        ]);

        // Если есть картинка
        if ($imagePath) {
            $relativeImagePath = str_replace('/images', 'public/bots', parse_url($imagePath, PHP_URL_PATH));
            if (Storage::exists($relativeImagePath)) {
                $absoluteImagePath = Storage::path($relativeImagePath);
                $photo = InputFile::create($absoluteImagePath, basename($absoluteImagePath));

                try {
                    $telegram->sendPhoto([
                        'chat_id' => $commonData['chatId'],
                        'photo'    => $photo,
                        'caption'  => $messageText,
                        'reply_markup' => $keyboard
                    ]);
                } catch (\Telegram\Bot\Exceptions\TelegramOtherException $e) {
                    // Если бот заблокирован
                    if ($e->getMessage() === 'Forbidden: bot was blocked by the user') {
                        $userModel = BotUser::where('telegram_id', $commonData['chatId'])->firstOrFail();
                        $userModel->is_banned = 1;
                        $userModel->save();
                    } else {
                        Log::info($e->getMessage());
                    }
                }
            } else {
                Log::error("Image file not found: " . $relativeImagePath);
            }
        } else {
            // Если картинки нет, отправляем обычное сообщение
            $telegram->sendMessage([
                'chat_id'      => $commonData['chatId'],
                'text'         => $messageText,
                'reply_markup' => $keyboard
            ]);
        }
    }
}



/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/CaloriesHandlers/TextMessageHandlers/StatsMessageHandler.php --- */
<?php

namespace App\Services\TelegramServices\CaloriesHandlers\TextMessageHandlers;

use App\Services\DiaryApiService;
use App\Utilities\Utilities;
use Illuminate\Support\Facades\Log;
use Telegram\Bot\Keyboard\Keyboard;

class StatsMessageHandler
{
    protected DiaryApiService $diaryApiService;

    public function __construct(DiaryApiService $diaryApiService)
    {
        $this->diaryApiService = $diaryApiService;
    }

    public function handle($bot, $telegram, $message)
    {
        $text = $message->getText();

        $chatId = $message->getChat()->getId();

        $botUser = Utilities::hasCaloriesId($chatId);

        $locale = $botUser->locale;

        if (!$botUser){
            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text'    => "Вы должны быть авторизированны!"
            ]);
            return;
        }

        if (str_contains($text, '/stats')) {
            $userId = $message->getFrom()->getId();

            $date = date('Y-m-d');
            $partOfDay = null;
            $commandParts = explode('_', $text);
            if (isset($commandParts[1])) {
                $partOfDay = $commandParts[1];
            }

            $responseArray = $this->diaryApiService->showUserStats($date, $partOfDay, $chatId, $locale);

            if (isset($responseArray['error'])) {
                $telegram->sendMessage([
                    'chat_id' => $chatId,
                    'text' => 'Произошла ошибка при получении данных. Пожалуйста, попробуйте позже.',
                ]);
                return;
            }
            if (!$partOfDay){
                Log::info($partOfDay);
            }
            if ($partOfDay){
                $messageText = $this->formatStatsMessage($responseArray, $date, $partOfDay, $chatId, $telegram);
            } else {
                $messageText = $this->formatTotalStatsMessage($responseArray, $date);
            }

            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text' => $messageText,
                'parse_mode' => 'Markdown',
            ]);
        }
    }
    protected function formatTotalStatsMessage($meals, $date)
    {
        if (empty($meals)) {
            return "У вас нет записей на дату *{$date}*.";
        }

        $partsOfDay = [
            'morning' => [
                'name' => 'Завтрак',
                'calories' => 0,
                'proteins' => 0,
                'fats' => 0,
                'carbohydrates' => 0,
            ],
            'dinner' => [
                'name' => 'Обед',
                'calories' => 0,
                'proteins' => 0,
                'fats' => 0,
                'carbohydrates' => 0,
            ],
            'supper' => [
                'name' => 'Ужин',
                'calories' => 0,
                'proteins' => 0,
                'fats' => 0,
                'carbohydrates' => 0,
            ],
        ];

        $total = [
            'calories' => 0,
            'proteins' => 0,
            'fats' => 0,
            'carbohydrates' => 0,
        ];

        foreach ($meals as $meal) {
            $part = $meal['part_of_day'];
            if (!isset($partsOfDay[$part])) {
                continue;
            }

            $quantityFactor = $meal['quantity'] / 100;

            $calories = $meal['calories'] * $quantityFactor;
            $proteins = $meal['proteins'] * $quantityFactor;
            $fats = $meal['fats'] * $quantityFactor;
            $carbohydrates = $meal['carbohydrates'] * $quantityFactor;

            $partsOfDay[$part]['calories'] += $calories;
            $partsOfDay[$part]['proteins'] += $proteins;
            $partsOfDay[$part]['fats'] += $fats;
            $partsOfDay[$part]['carbohydrates'] += $carbohydrates;

            $total['calories'] += $calories;
            $total['proteins'] += $proteins;
            $total['fats'] += $fats;
            $total['carbohydrates'] += $carbohydrates;
        }

        $messageText = "Ваши данные за *{$date}*:\n\n";

        foreach ($partsOfDay as $part) {
            if ($part['calories'] == 0) {
                continue;
            }
            $productArray = [
                [ "Калории", round($part['calories'])],
                [ "Белки", round($part['proteins'])],
                [ "Жиры", round($part['fats'])],
                [ "Углеводы",round( $part['carbohydrates'])],
            ];
            $messageText .= Utilities::generateTableType2($part['name'] , $productArray) . "\n\n";

        }
        $productArray = [
            [ "Калории", round($total['calories'])],
            [ "Белки", round($total['proteins'])],
            [ "Жиры", round($total['fats'])],
            [ "Углеводы",round( $total['carbohydrates'])],
        ];
        $messageText .= Utilities::generateTableType2('Итого за день' , $productArray);

        return $messageText;
    }
    protected function formatStatsMessage($meals, $date, $partOfDay, $chatId, $telegram)
    {
        if (empty($meals)) {
            $partOfDayText = $partOfDay ? "за *{$partOfDay}*" : "на дату *{$date}*";
            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text' => "У вас нет записей {$partOfDayText}.",
                'parse_mode' => 'Markdown',
            ]);
            return;
        }

        $total = [
            'calories' => 0,
            'proteins' => 0,
            'fats' => 0,
            'carbohydrates' => 0,
        ];

        foreach ($meals as $meal) {

            $quantityFactor = $meal['quantity'] / 100;

            $calories = $meal['calories'] * $quantityFactor;
            $proteins = $meal['proteins'] * $quantityFactor;
            $fats = $meal['fats'] * $quantityFactor;
            $carbohydrates = $meal['carbohydrates'] * $quantityFactor;

            $total['calories'] += $calories;
            $total['proteins'] += $proteins;
            $total['fats'] += $fats;
            $total['carbohydrates'] += $carbohydrates;

            $productArray = [
                ["Калории", round($calories)],
                ["Белки", round($proteins)],
                ["Жиры", round($fats)],
                ["Углеводы", round($carbohydrates)],
            ];

            $messageText = Utilities::generateTableType2($meal['name'] . " ({$meal['quantity']}г)", $productArray);

            $inlineKeyboard = [
                [
                    [
                        'text' => 'Удалить',
                        'callback_data' => 'delete_meal_' . $meal['id']
                    ]
                ]
            ];

            $replyMarkup = json_encode(['inline_keyboard' => $inlineKeyboard]);

            $telegram->sendMessage([
                'chat_id' => $chatId,
                'text' => $messageText,
                'parse_mode' => 'Markdown',
                'reply_markup' => $replyMarkup,
            ]);
        }

        $productArray = [
            ["Калории", round($total['calories'])],
            ["Белки", round($total['proteins'])],
            ["Жиры", round($total['fats'])],
            ["Углеводы", round($total['carbohydrates'])],
        ];

        $partOfDayName = $this->getPartOfDayName($partOfDay);
        $messageText = Utilities::generateTableType2("Итого за {$partOfDayName}", $productArray);



        return $messageText;
    }

    private function getPartOfDayName($partOfDay)
    {
        switch ($partOfDay) {
            case 'morning':
                return 'Завтрак';
            case 'dinner':
                return 'Обед';
            case 'supper':
                return 'Ужин';
            default:
                return 'день';
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/ApprovalHandlers/ContactMessageHandler.php --- */
<?php

namespace App\Services\TelegramServices\ApprovalHandlers;

use App\Models\BotUser;
use App\Services\TelegramServices\BaseHandlers\MessageHandlers\MessageHandlerInterface;
use App\Traits\BasicDataExtractor;
use App\Traits\ContactDataExtractor;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class ContactMessageHandler implements MessageHandlerInterface
{
    use BasicDataExtractor, ContactDataExtractor;

    public function handle($bot, $telegram, $message)
    {

        $commonData = self::extractCommonData($message);
        $contactData = self::extractContactData($message);

        if (!$contactData) {
            $telegram->sendMessage([
                'chat_id' => $commonData['chatId'],
                'text' => 'Ошибка, попробуйте перейти по ссылке еще раз!',
            ]);
            return;
        }

        $user = BotUser::where('telegram_id', $contactData['telegramId'])->first();
        if ($user) {
            $user->phone = $contactData['phoneNumber'];
            $user->save();
        }

        $userIdFromWordpress = Cache::get($commonData['chatId']);
        if (!$userIdFromWordpress) {
            $telegram->sendMessage([
                'chat_id' => $commonData['chatId'],
                'text' => 'Ошибка, попробуйте перейти по ссылке еще раз!',
            ]);
            return;
        }

        $phoneNumber = preg_replace('/[^0-9]/', '', $contactData['phoneNumber']);

        $data = [
            'wp_id' => $userIdFromWordpress,
            'tg_id' => $commonData['chatId'],
            'tg_username' => $commonData['username'],
            'tg_number' => $phoneNumber
        ];

        try {
            $url = $bot->wordpress_endpoint;
//            $response = Http::asForm()->post($url, $data);
//            $body = $response->body();
//            Log::info(print_r($body, true));

            $body = '/ID already exists/';

            $patterns = [
                '/Wrong Query/' => 'Ошибка, попробуйте перейти по ссылке еще раз!',
                '/Number already exists/' => 'Ваш номер уже есть в базе!',
                '/Success/' => 'Успех!',
                '/User does not exist/' => 'Такого пользователя не существует!',
                '/Number code invalid/' => 'Недопустимый код номера!',
                '/ID already exists/' => 'Ваш ID уже есть в базе!'
            ];

            foreach ($patterns as $pattern => $message) {
                if (preg_match($pattern, $body)) {
                    $telegram->sendMessage([
                        'chat_id' => $commonData['chatId'],
                        'text' => $message,
                    ]);
                    break;
                }
            }
        } catch (\Exception $e) {
            Log::error("Error accessing /test.wp: " . $e->getMessage());
        }
    }
}


/* --- FILE: /var/www/bot-panel/app/Services/TelegramServices/ApprovalHandlers/TextMessageHandler.php --- */
<?php

namespace App\Services\TelegramServices\ApprovalHandlers;

use App\Services\TelegramServices\BaseHandlers\MessageHandlers\MessageHandlerInterface;
use App\Traits\BasicDataExtractor;
use App\Utilities\Utilities;
use Illuminate\Support\Facades\Cache;
use Telegram\Bot\Keyboard\Keyboard;

class TextMessageHandler implements MessageHandlerInterface
{
    use BasicDataExtractor;

    public function handle($bot, $telegram, $message)
    {

        $commonData = self::extractCommonData($message);
        $text = $message->getText();

        $isPhone = Utilities::isPhoneNumber($text);

        if ($isPhone) {
            $telegram->sendMessage([
                'chat_id' => $commonData['chatId'],
                'text' => 'Для подтверждения номера надо нажать на кнопку "Поделится контактом"!',
            ]);
            return;
        }

        $userIdFromWordpress = Utilities::getParam($message) ?? '';

        if (!$userIdFromWordpress) {
            $telegram->sendMessage([
                'chat_id' => $commonData['chatId'],
                'text' => 'Ошибка, попробуйте перейти по ссылке еще раз!',
            ]);
            return;
        }

        Cache::put($commonData['chatId'], $userIdFromWordpress, 60);

        if (str_contains($text, '/start')) {
            $keyboard = Keyboard::make([
                'resize_keyboard' => true,
                'one_time_keyboard' => true
            ])->row([
                [
                    'text' => 'Поделиться контактом',
                    'request_contact' => true
                ]
            ]);

            $telegram->sendMessage([
                'chat_id' => $commonData['chatId'],
                'text' => 'Пожалуйста, поделитесь вашим контактом.',
                'reply_markup' => $keyboard
            ]);
        }
    }
}
